// Whenever a new channel is created, In and Out smart-pointers should be created that point to it.
// The channel will be deleted as soon as both In and Out objects are deleted.
// At creation, the source and target are the object that spawned the channel (or the intended object). If a
// In or Out pointer is deleted, it sets the channel's source/target pointer to nullptr. 

#ifndef CHANNEL_H
#define CHANNEL_H


#include <deque>
#include <functional>
#include <exception>

#include "SpatialFunction.h"
//#include "SpaceTimeObject.h"
#include "ThreadPool.h"
#include "spacetime/ReferenceFrame.h"

template<SpaceTime SPACETIME> class SpaceTimeBase;
template<class T, ReferenceFrame FRAME> class SpaceTimeObject;
template<class T, ReferenceFrame FRAME> class SpaceTimePtr;

template<class T, ReferenceFrame FRAME>
class Channel {
    public:
        typedef typename FRAME::SpaceTime SpaceTime;

    protected:
    SpaceTimeBase<SpaceTime> *       source = nullptr; // null if closed (target will block after processing the last item in the buffer)
    SpaceTimeObject<T,FRAME> *              target = nullptr;
    std::deque<SpatialFunction<T,FRAME>>    buffer;
//    char                                    flags = 0;

    // channel needs to poll source for position and signal that it is blocking
    // and needs to be able to signal to target that it has been unblocked

    // enum State {
    //     OPEN,
    //     CLOSED,
    //     CONNECTING,  // waiting for other end to connect
    //     NOCHANNEL    // channel hasn't been created yet 
    // };

    // static constexpr is_blocking_flag = 1;
    // static constexpr has_connected_in_flag = 2;
    // static constexpr has_connected_out_flag = 4;

    void unblock() {
        if(target != nullptr) {
//            flags ^= is_blocking_flag;
            (*target)();
        }
//        if(souce == nullptr) delete(this);
    }

//    bool isBlocking() { return flags & is_blocking_flag; }

    Channel(SpaceTimeBase<SpaceTime> &source, SpaceTimeObject<T,FRAME> &target) : source(&source), target(&target) { }

    Channel(const Channel<T,FRAME> &other) = delete; // just don't copy channels

public:


    // friend class SpaceTimeObject<T,FRAME>;
    // friend class SpaceTimePtr<T,FRAME>;


    class In {
    protected:
        In(Channel<T, FRAME> *channel) : channel(channel) { }

        // friend class Out;
    public:

        In(const In &dummy) { // here to allow capture in std::function
            throw(std::runtime_error("Channels can only be moved"));
        }

        In(In &&moveFrom) : channel(moveFrom.channel) {
            moveFrom.channel = nullptr;
        }

        ~In() {
            if(channel != nullptr) {
                channel->target = nullptr;
                if(channel->source == nullptr) {
                    delete(channel);
                } else {
                    channel->buffer.clear(); // delete any captured channels
                }
            }
        }

        // void pop() { channel->buffer.pop_front(); }
        // const SpatialFunction<T, FRAME> &front() { return channel->buffer.front(); }

        void executeNext(SpaceTimePtr<T,FRAME> obj) { // obj should always be the target (pointer to target can be a SpaceTimePtr)
            channel->buffer.front()(obj);
            channel->buffer.pop_front();
        }

        // position of the front of the queue, or source if empty
        // nullptr if closed and empty
        const SpaceTime &position() const {
            return (empty() ?
                (channel->source != nullptr ? channel->source->position : SpaceTime::TOP) 
                : channel->buffer.front().position);
        }

        // tell source to callback target on move
        void setBlockingCallback() {
            if(channel->source != nullptr) {
                channel->source->callbackOnMove([&channel = this->channel]() { channel.unblock(); });
//                flags |= is_blocking_flag;
            }
        }

        bool empty() { return channel->buffer.empty(); }

        // State state() {
        //     if(channel.source == nullptr) {
        //         return (channel.flags & has_connected_out_flag) ? CLOSED : CONNECTING;
        //     }
        //     return OPEN;
        // }

    protected:
        Channel<T, FRAME> *channel;
    };
    

    class Out
    {
    protected:
    public:
        Out() : channel(nullptr) {}

        // open a channel on the source side
        Out(SpaceTimeBase<SpaceTime> &source, Out &target) {
            channel = new Channel<T,FRAME>(source, target.channel->target);
            target.send([inChannel = In(channel)](SpaceTimePtr<T,FRAME> obj) {
                obj.attach(inChannel);
            });
        }

        Out(SpaceTimePtr<T,FRAME> &source, Out &target) : Out(source.ptr, target) { }

        // Out(SpaceTimeBase<FRAME> *source, SpaceTimeObject<T, FRAME> *target) {
        //     channel = new Channel<T, FRAME>();
        //     target->connect(channel);
        //     channel->open(source);
        // }

        // move a channel from another to this
        Out(Out &&moveFrom) : channel(moveFrom.channel) {
            moveFrom.channel = nullptr;
        }

        ~Out() {
            if(channel != nullptr) {
                channel->source = nullptr;
                if(channel->target == nullptr) delete(channel);
            }
        }

        Out &operator=(Out &&moveFrom) {
            channel = moveFrom.channel;
            moveFrom.channel = nullptr;
            return *this;
        }

        template <class LAMBDA>
        bool send(LAMBDA &&function) {
            bool success = false;
            if(isOpen()) {
                channel->buffer.emplace_back(channel->source->position, std::forward<LAMBDA>(function));
                success = true;
            }
            return success;
        }

        // void close() {
        //     State s = state();
        //     if(s != NOCHANNEL) {
        //         channel->source = nullptr;
        //         if(s == CLOSED) {
        //             if(!channel->isBlocking()) delete channel; // delay deletion of blocking so that channel can unblock
        //         } else {
        //             if(channel->buffer.empty()) {
        //                 // place null task on buffer to ensure the target sees the channel close
        //                 send([](SpaceTimePtr<T,FRAME>){});
        //             }
        //         }
        //         channel = nullptr;
        //     }
        // }

        // create a new channel whose target is the same as this, by sending a message down this channel.
        Channel<T,FRAME> *newChannel() {
            Channel *newChannel = new Channel<T, FRAME>();
            // send connection code to target
            send([chan = newChannel](SpaceTimePtr<T, FRAME> targetObj) {
                targetObj.connectIn(*chan);
            });
            return newChannel;
        }

        // bool isConnected() { return channel != nullptr; } // ... to a channel
        // bool isOpen() { return isConnected() && channel->target != nullptr; } // ... to a target

//        State state() {
//            if(channel == nullptr) return NOCHANNEL;
//            if(channel->source == nullptr) {
//                return (channel->flags & has_connected_in_flag) ? CLOSED : CONNECTING;
//            }
//            return OPEN;
//        }

    protected:
        Channel<T, FRAME> *channel;
    };


    // Represents the write-end of a channel that hasn't yet been connected to an object
    // This provides a dummy object to connect to in the meantime.
    class Unattached : public SpaceTimeBase<SpaceTime> {
    public:
    
        // create a new channel with a given target
        Unattached(const Out &target) : outChannel(*this, target) { }

        // Unattached(Unattached &&other) channel(std::move(other.channel)) {
        // }

        Unattached(const Unattached &dummy) {
            throw(std::runtime_error("Don't try to copy construct a Channel. Use std::move instead"));
        }

        Out &&get(SpaceTimePtr<T,FRAME> attachTo) {
            outChannel.channel->source = attachTo.ptr; 
            return std::move(outChannel);
        }

    protected:
        Out outChannel;
    };





    // template<class SRCTYPE>
    // Out open(SpaceTimePtr<SRCTYPE,FRAME> src) {
    //     if(source != nullptr) throw(std::runtime_error("Channel already connected to a source"));
    //     source = src.ptr;
    //     return Out(this);
    // }

    // In open(SpaceTimeObject<T,FRAME> *target) {
    //     if(this->target != nullptr) throw(std::runtime_error("Channel already connected to a target"));
    //     this->target = target;
    //     return In(this);
    // }

    // OutChannel<T,FRAME> openOut(SpaceTimeBase<T,FRAME> *);


//    Channel(SpaceTimeBase<FRAME> *sourcePtr = nullptr, SpaceTimeObject<T,FRAME> *targetPtr = nullptr) : source(sourcePtr), target(targetPtr) {}

};

#endif
